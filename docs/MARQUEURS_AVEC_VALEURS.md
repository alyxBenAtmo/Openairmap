# Marqueurs avec Valeurs Affich√©es - Documentation

## üéØ Vue d'ensemble

Le syst√®me de marqueurs avec valeurs affich√©es permet d'afficher directement la valeur de mesure (arrondie) sur chaque marqueur PNG de la carte. Cette fonctionnalit√© am√©liore l'exp√©rience utilisateur en permettant de voir imm√©diatement les valeurs sans avoir √† cliquer sur les marqueurs.

## üèóÔ∏è Architecture Technique

### Approche Choisie

Nous utilisons des **marqueurs HTML personnalis√©s** (L.divIcon) plut√¥t que des marqueurs Canvas dynamiques pour les raisons suivantes :

- **Performance** : Plus rapide que la g√©n√©ration de Canvas
- **Simplicit√©** : Code plus maintenable
- **Flexibilit√©** : Facile √† personnaliser avec CSS
- **Compatibilit√©** : Fonctionne sur tous les navigateurs

### Structure des Marqueurs

```html
<div class="custom-marker-container">
  <img src="/markers/source_qualityLevel.png" alt="marker" />
  <div class="value-text">42</div>
</div>
```

## üé® Styles CSS

### Classes Principales

```css
.custom-marker-div {
  background: transparent !important;
  border: none !important;
}

.custom-marker-container {
  position: relative;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
}

.custom-marker-container img {
  width: 100%;
  height: 100%;
  display: block;
  object-fit: contain;
  pointer-events: none;
}

.value-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 12px;
  font-weight: bold;
  font-family: Arial, sans-serif;
  text-align: center;
  line-height: 1;
  pointer-events: none;
  user-select: none;
  z-index: 10;
  text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.9);
}
```

## üìä Logique d'Affichage

### Conditions d'Affichage

La valeur n'est affich√©e que si :

1. L'appareil a le statut `"active"`
2. La valeur de mesure est sup√©rieure √† 0
3. Le niveau de qualit√© n'est pas `"default"`

### Format de la Valeur

- **Arrondi** : La valeur est arrondie √† l'entier le plus proche
- **Pas d'unit√©** : Seule la valeur num√©rique est affich√©e
- **Taille adaptative** : Police qui s'ajuste selon la longueur de la valeur
  - 1 chiffre : 18px
  - 2 chiffres : 16px
  - 3+ chiffres : 12px

## üîÑ Adaptation aux Autres Sources de Donn√©es

### Structure Unifi√©e

Toutes les sources de donn√©es utilisent la m√™me interface `MeasurementDevice` :

```typescript
interface MeasurementDevice {
  id: string;
  name: string;
  latitude: number;
  longitude: number;
  source: string;
  pollutant: string;
  value: number; // ‚Üê Valeur utilis√©e pour l'affichage
  unit: string;
  timestamp: string;
  status: "active" | "inactive" | "error";
  qualityLevel?: string; // bon, moyen, degrade, mauvais, tresMauvais, extrMauvais, default
  address?: string;
  departmentId?: string;
}
```

### Sources Actuellement Support√©es

#### AtmoRef (AtmoSud)

- **Champ de valeur** : `measure.valeur`
- **Statut** : Bas√© sur la pr√©sence de mesures r√©centes
- **Qualit√©** : Utilis√© les seuils par polluant via `getAirQualityLevel()`

#### SignalAir (Signalements Qualitatifs)

- **Champ de valeur** : Pas de valeur num√©rique (signalements qualitatifs)
- **Statut** : Toujours `"active"` pour les signalements r√©cents
- **Qualit√©** : Pas de qualit√©, utilise `signalType` pour le marqueur
- **Marqueur sp√©cial** : Pas de texte affich√©, seulement l'ic√¥ne du type de signalement

#### Sources √† Int√©grer

##### AtmoMicro

- **Champ de valeur** : Probablement `measure.valeur` ou `measure.value`
- **Statut** : Bas√© sur la fra√Æcheur des donn√©es
- **Qualit√©** : Utilis√© les seuils par polluant via `getAirQualityLevel()`

##### NebuleAir (Capteurs communautaires)

- **Champ de valeur** : `sensor.value` ou `measurement.value`
- **Statut** : Bas√© sur la connectivit√© du capteur
- **Qualit√©** : Utilis√© les seuils par polluant via `getAirQualityLevel()`

##### PurpleAir

- **Champ de valeur** : `sensor.pm2.5_atm` ou `sensor.pm10_atm`
- **Statut** : Bas√© sur la derni√®re transmission
- **Qualit√©** : Utilis√© les seuils par polluant via `getAirQualityLevel()`

##### Sensor.Community

- **Champ de valeur** : `sensor.P1` (PM10) ou `sensor.P2` (PM2.5)
- **Statut** : Bas√© sur la derni√®re mise √† jour
- **Qualit√©** : Utilis√© les seuils par polluant via `getAirQualityLevel()`

## üõ†Ô∏è Impl√©mentation Technique

### Fonction de Cr√©ation des Marqueurs

```typescript
const createCustomIcon = (device: MeasurementDevice) => {
  const qualityLevel = device.qualityLevel || "default";
  const markerPath = getMarkerPath(device.source, qualityLevel);

  // Cr√©er un √©l√©ment HTML personnalis√© pour le marqueur
  const div = document.createElement("div");
  div.className = "custom-marker-container";

  // Image de base du marqueur
  const img = document.createElement("img");
  img.src = markerPath;
  img.alt = `${device.source} marker`;

  // Ajouter une animation subtile pendant le chargement
  if (loading) {
    div.style.opacity = "0.7";
    div.style.transform = "scale(0.95)";
    div.style.transition = "all 0.3s ease";
  }

  // Texte de la valeur pour les appareils de mesure
  const valueText = document.createElement("div");
  valueText.className = "value-text";

  // Gestion normale pour les appareils de mesure
  if (device.status === "active" && device.value > 0) {
    const displayValue = Math.round(device.value);
    valueText.textContent = displayValue.toString();

    // Ajuster la taille du texte selon la longueur de la valeur
    if (displayValue >= 100) {
      valueText.style.fontSize = "12px"; // Police plus petite pour les valeurs √† 3 chiffres
    } else if (displayValue >= 10) {
      valueText.style.fontSize = "16px"; // Police moyenne pour les valeurs √† 2 chiffres
    } else {
      valueText.style.fontSize = "18px"; // Police normale pour les valeurs √† 1 chiffre
    }

    // Couleur du texte selon le niveau de qualit√©
    const textColors: Record<string, string> = {
      bon: "#000000",
      moyen: "#000000",
      degrade: "#000000",
      mauvais: "#000000", // Noir au lieu de blanc pour les marqueurs rouges
      tresMauvais: "#000000", // Noir au lieu de blanc pour les marqueurs rouges
      extrMauvais: "#000000", // Noir au lieu de blanc pour les marqueurs rouges
      default: "#666666",
    };

    valueText.style.color = textColors[qualityLevel] || "#000000";

    // Ajouter un contour blanc pour am√©liorer la lisibilit√©
    if (qualityLevel !== "default") {
      // Contour plus subtil pour √©viter l'effet de "pat√©"
      valueText.style.textShadow =
        "1px 1px 2px rgba(255,255,255,0.8), -1px -1px 2px rgba(255,255,255,0.8)";
    }
  }

  div.appendChild(img);
  div.appendChild(valueText);

  return L.divIcon({
    html: div.outerHTML,
    className: "custom-marker-div",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
  });
};
```

### Fonction de Cr√©ation des Marqueurs SignalAir

```typescript
const createSignalIcon = (report: SignalAirReport) => {
  const qualityLevel = report.qualityLevel || "default";
  const markerPath = getMarkerPath(report.source, qualityLevel);

  // Cr√©er un √©l√©ment HTML personnalis√© pour le marqueur de signalement
  const div = document.createElement("div");
  div.className = "custom-marker-container";

  // Image de base du marqueur
  const img = document.createElement("img");
  img.src = markerPath;
  img.alt = `${report.source} signal marker`;

  // Ajouter une animation subtile pendant le chargement
  if (loading) {
    div.style.opacity = "0.7";
    div.style.transform = "scale(0.95)";
    div.style.transition = "all 0.3s ease";
  }

  // Pour SignalAir, on n'ajoute pas de texte par-dessus le marqueur
  div.appendChild(img);

  return L.divIcon({
    html: div.outerHTML,
    className: "custom-marker-div",
    iconSize: [32, 32],
    iconAnchor: [16, 32],
  });
};
```

### Fonction Utilitaires

#### getMarkerPath()

```typescript
export function getMarkerPath(source: string, level: string): string {
  // Gestion sp√©ciale pour SignalAir
  if (source === "signalair") {
    const signalTypeMapping: Record<string, string> = {
      odeur: "odeur",
      bruit: "bruits", // Le fichier s'appelle "bruits.png"
      brulage: "brulage",
      visuel: "visuel",
      pollen: "pollen",
    };

    const signalType = signalTypeMapping[level] || "odeur";
    return `/markers/signalAirMarkers/${signalType}.png`;
  }

  // Gestion pour les autres sources
  const sourceMapping: Record<string, string> = {
    atmoRef: "atmoRefMarkers/refStationAtmoSud",
    atmoMicro: "atmoMicroMarkers/microStationAtmoSud",
    nebuleAir: "nebuleAirMarkers/nebuleAir",
    purpleAir: "purpleAirMarkers/purpleAir",
    sensorCommunity: "sensorCommunityMarkers/SensorCommunity",
  };

  const basePath = sourceMapping[source] || "atmoRefMarkers/refStationAtmoSud";
  return `/markers/${basePath}_${level}.png`;
}
```

#### getAirQualityLevel()

```typescript
export function getAirQualityLevel(value: number, thresholds: Seuils): string {
  if (value <= thresholds.bon.max) return "bon";
  if (value <= thresholds.moyen.max) return "moyen";
  if (value <= thresholds.degrade.max) return "degrade";
  if (value <= thresholds.mauvais.max) return "mauvais";
  if (value <= thresholds.tresMauvais.max) return "tresMauvais";
  return "extrMauvais";
}
```

## üîß Configuration et Personnalisation

### Modifier la Taille du Texte

Pour adapter la taille selon la valeur :

```typescript
// Ajustement automatique selon la longueur de la valeur
if (displayValue >= 100) {
  valueText.style.fontSize = "12px"; // Police plus petite pour les grandes valeurs
} else if (displayValue >= 10) {
  valueText.style.fontSize = "16px"; // Police moyenne pour les valeurs √† 2 chiffres
} else {
  valueText.style.fontSize = "18px"; // Police normale pour les valeurs √† 1 chiffre
}
```

### Couleurs du Texte

```typescript
// Couleur du texte selon le niveau de qualit√©
const textColors: Record<string, string> = {
  bon: "#000000",
  moyen: "#000000",
  degrade: "#000000",
  mauvais: "#000000", // Noir au lieu de blanc pour les marqueurs rouges
  tresMauvais: "#000000", // Noir au lieu de blanc pour les marqueurs rouges
  extrMauvais: "#000000", // Noir au lieu de blanc pour les marqueurs rouges
  default: "#666666",
};
```

### Contour du Texte

```typescript
// Ajouter un contour blanc pour am√©liorer la lisibilit√©
if (qualityLevel !== "default") {
  // Contour plus subtil pour √©viter l'effet de "pat√©"
  valueText.style.textShadow =
    "1px 1px 2px rgba(255,255,255,0.8), -1px -1px 2px rgba(255,255,255,0.8)";
}
```

## üìÅ Structure des Fichiers de Marqueurs

```
public/markers/
‚îú‚îÄ‚îÄ atmoRefMarkers/
‚îÇ   ‚îú‚îÄ‚îÄ refStationAtmoSud_bon.png
‚îÇ   ‚îú‚îÄ‚îÄ refStationAtmoSud_moyen.png
‚îÇ   ‚îú‚îÄ‚îÄ refStationAtmoSud_degrade.png
‚îÇ   ‚îú‚îÄ‚îÄ refStationAtmoSud_mauvais.png
‚îÇ   ‚îú‚îÄ‚îÄ refStationAtmoSud_tresMauvais.png
‚îÇ   ‚îú‚îÄ‚îÄ refStationAtmoSud_extrMauvais.png
‚îÇ   ‚îî‚îÄ‚îÄ refStationAtmoSud_default.png
‚îú‚îÄ‚îÄ atmoMicroMarkers/
‚îÇ   ‚îú‚îÄ‚îÄ microStationAtmoSud_bon.png
‚îÇ   ‚îú‚îÄ‚îÄ microStationAtmoSud_moyen.png
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ nebuleAirMarkers/
‚îÇ   ‚îú‚îÄ‚îÄ nebuleAir_bon.png
‚îÇ   ‚îú‚îÄ‚îÄ nebuleAir_moyen.png
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ purpleAirMarkers/
‚îÇ   ‚îú‚îÄ‚îÄ purpleAir_bon.png
‚îÇ   ‚îú‚îÄ‚îÄ purpleAir_moyen.png
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ sensorCommunityMarkers/
‚îÇ   ‚îú‚îÄ‚îÄ SensorCommunity_bon.png
‚îÇ   ‚îú‚îÄ‚îÄ SensorCommunity_moyen.png
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ signalAirMarkers/
    ‚îú‚îÄ‚îÄ odeur.png
    ‚îú‚îÄ‚îÄ bruits.png
    ‚îú‚îÄ‚îÄ brulage.png
    ‚îú‚îÄ‚îÄ visuel.png
    ‚îî‚îÄ‚îÄ pollen.png
```

## üöÄ √âvolutions Futures

### Fonctionnalit√©s Possibles

1. **Affichage conditionnel** : Option pour masquer/afficher les valeurs
2. **Format personnalis√©** : Choix entre valeur arrondie ou d√©cimale
3. **Animations** : Transitions lors des changements de valeurs
4. **Filtres visuels** : Masquer les marqueurs selon des seuils
5. **Mode nuit** : Couleurs adapt√©es pour l'affichage nocturne

### Optimisations

1. **Cache des marqueurs** : Mise en cache des √©l√©ments HTML g√©n√©r√©s
2. **Lazy loading** : Chargement diff√©r√© des marqueurs hors √©cran
3. **Clustering** : Regroupement des marqueurs proches
4. **Compression** : Optimisation des images de marqueurs

## üìù Notes de D√©veloppement

### Bonnes Pratiques

- Toujours v√©rifier le statut de l'appareil avant d'afficher une valeur
- Utiliser des couleurs contrast√©es pour la lisibilit√©
- Tester sur diff√©rents navigateurs et tailles d'√©cran
- Maintenir la coh√©rence visuelle entre toutes les sources
- Utiliser `getAirQualityLevel()` pour calculer le niveau de qualit√©
- Utiliser `getMarkerPath()` pour obtenir le chemin du marqueur

### D√©pannage

- **Valeurs non affich√©es** : V√©rifier le statut et la valeur de l'appareil
- **Texte illisible** : V√©rifier les couleurs et le contraste
- **Marqueurs manquants** : V√©rifier les chemins d'images et les classes CSS
- **Performance** : Surveiller le nombre de marqueurs g√©n√©r√©s

### Int√©gration de Nouvelles Sources

Pour int√©grer une nouvelle source de donn√©es :

1. **Cr√©er le service** : Impl√©menter un service qui √©tend `BaseDataService`
2. **Ajouter les marqueurs** : Cr√©er les images PNG pour chaque niveau de qualit√©
3. **Mettre √† jour `getMarkerPath()`** : Ajouter le mapping pour la nouvelle source
4. **Tester l'affichage** : V√©rifier que les valeurs s'affichent correctement
5. **Ajouter au factory** : Int√©grer dans `DataServiceFactory`

### Exemple d'Int√©gration

```typescript
// 1. Ajouter le mapping dans getMarkerPath()
const sourceMapping: Record<string, string> = {
  // ... sources existantes
  nouvelleSource: "nouvelleSourceMarkers/nouvelleSource",
};

// 2. Cr√©er les fichiers de marqueurs
// public/markers/nouvelleSourceMarkers/nouvelleSource_bon.png
// public/markers/nouvelleSourceMarkers/nouvelleSource_moyen.png
// etc.

// 3. Dans le service, calculer le qualityLevel
const qualityLevel = getAirQualityLevel(device.value, pollutant.thresholds);

// 4. Retourner un MeasurementDevice avec qualityLevel
return {
  // ... autres propri√©t√©s
  qualityLevel,
  status: "active", // ou "inactive" selon les donn√©es
};
```

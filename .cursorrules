# ReactOpenAirMap - RÃ¨gles de dÃ©veloppement

## ğŸ¯ Architecture et Structure
- Maintenir une architecture modulaire avec sÃ©paration claire des responsabilitÃ©s
- Utiliser des composants React fonctionnels avec TypeScript
- Organiser le code en dossiers : components/, services/, hooks/, constants/, types/, utils/
- ImplÃ©menter une factory pattern pour les services de donnÃ©es (DataServiceFactory)
- CrÃ©er des hooks personnalisÃ©s pour la logique mÃ©tier (useAirQualityData)

## ğŸ—ºï¸ Carte et Interface
- Utiliser Leaflet pour l'affichage de la carte interactive
- IntÃ©grer les contrÃ´les directement sur la carte en menus flottants
- Maintenir un z-index Ã©levÃ© (z-[2000]) pour les menus au-dessus de la carte
- Afficher les marqueurs colorÃ©s selon les valeurs de qualitÃ© de l'air
- Utiliser des icÃ´nes personnalisÃ©es pour chaque type de source de donnÃ©es
- ImplÃ©menter un systÃ¨me de marqueurs avec codes couleur selon les seuils de polluants

## ğŸ›ï¸ Menus de ContrÃ´le
- CrÃ©er des menus dÃ©roulants avec Tailwind CSS pour une interface moderne
- ImplÃ©menter des checkboxes personnalisÃ©es avec Ã©tats visuels clairs
- Maintenir une hiÃ©rarchie visuelle avec sections et sous-menus
- Permettre la sÃ©lection multiple pour les sources de donnÃ©es
- Afficher les Ã©tats partiellement sÃ©lectionnÃ©s pour les groupes
- Utiliser des animations fluides et des transitions pour l'UX
- Fermer automatiquement les menus en cliquant Ã  l'extÃ©rieur

## ğŸ“Š Gestion des DonnÃ©es
- Refaire automatiquement les appels API quand un paramÃ¨tre change
- GÃ©rer les Ã©tats de chargement et d'erreur pour chaque source
- Adapter les requÃªtes selon le format attendu par chaque source
- Utiliser des services spÃ©cifiques pour chaque type de source de donnÃ©es
- Maintenir une cohÃ©rence des donnÃ©es entre les diffÃ©rentes sources

## ğŸ”„ Logique de Mise Ã  Jour
- DÃ©clencher de nouveaux appels API Ã  chaque changement de paramÃ¨tre
- Passer les paramÃ¨tres sÃ©lectionnÃ©s Ã  tous les services actifs
- Adapter les requÃªtes selon le polluant sÃ©lectionnÃ© (PMâ‚‚.â‚…, PMâ‚â‚€, Oâ‚ƒ, etc.)
- Adapter les requÃªtes selon le pas de temps (Scan, â‰¤2min, 15min, Heure, Jour)
- GÃ©rer la sÃ©lection/dÃ©sÃ©lection des sources de donnÃ©es
- Maintenir la cohÃ©rence entre l'interface et les donnÃ©es affichÃ©es

## ğŸ¨ Design et UX
- Utiliser Tailwind CSS pour un design cohÃ©rent et moderne
- ImplÃ©menter des Ã©tats visuels clairs (sÃ©lectionnÃ©, partiellement sÃ©lectionnÃ©, non sÃ©lectionnÃ©)
- Utiliser des couleurs cohÃ©rentes (bleu pour les sÃ©lections, gris pour les Ã©tats neutres)
- CrÃ©er des hover effects et transitions fluides
- Assurer une bonne lisibilitÃ© avec des contrastes appropriÃ©s
- Rendre l'interface responsive pour diffÃ©rents Ã©crans

## ï¿½ï¿½ Sources de DonnÃ©es - ImplÃ©mentation
- Maintenir l'ordre des sources : AtmoRef, AtmoMicro, Capteurs communautaires, SignalAir
- ImplÃ©menter des services spÃ©cifiques pour chaque source (AtmoRefService, AtmoMicroService, etc.)
- GÃ©rer les formats de donnÃ©es diffÃ©rents entre les sources
- Permettre la sÃ©lection/dÃ©sÃ©lection en masse des groupes communautaires
- Adapter les requÃªtes selon les spÃ©cificitÃ©s de chaque API
- Maintenir la cohÃ©rence des noms et codes entre l'interface et les services

### ğŸ”§ Architecture des Services de DonnÃ©es
- **BaseDataService** : Classe abstraite avec mÃ©thodes communes (fetchData, transformData, handleError)
- **Interfaces communes** : DÃ©finir des interfaces pour les paramÃ¨tres et rÃ©ponses standardisÃ©es
- **Transformateurs de donnÃ©es** : CrÃ©er des fonctions de transformation spÃ©cifiques Ã  chaque source
- **Gestion d'erreurs** : ImplÃ©menter une gestion d'erreur robuste pour chaque service
- **Validation des donnÃ©es** : Valider les donnÃ©es reÃ§ues avant transformation

### ğŸ“¡ Formats de RequÃªtes et RÃ©ponses
- **AtmoRef/AtmoMicro** : APIs REST avec authentification, format JSON standardisÃ©
- **NebuleAir** : API GraphQL ou REST, format de donnÃ©es communautaire
- **Sensor.Community** : API REST avec format spÃ©cifique aux capteurs citoyens
- **PurpleAir** : API REST avec authentification, format JSON propriÃ©taire
- **SignalAir** : API REST avec format de signalement (qualitatif vs quantitatif)

### ğŸ”„ Transformation des DonnÃ©es
- **Normalisation** : Convertir tous les formats vers une structure commune
- **Mapping des polluants** : Adapter les codes de polluants entre sources
- **Conversion d'unitÃ©s** : Standardiser les unitÃ©s de mesure (Âµg/mÂ³, ppm, etc.)
- **Gestion des timestamps** : Normaliser les formats de dates/heures
- **Validation des valeurs** : Filtrer les valeurs aberrantes ou manquantes

### ğŸ›¡ï¸ Gestion des Erreurs par Source
- **Timeouts** : GÃ©rer les timeouts spÃ©cifiques Ã  chaque API
- **Rate limiting** : Respecter les limites de requÃªtes par source
- **Authentification** : GÃ©rer les erreurs d'authentification (API keys, tokens)
- **Format de rÃ©ponse** : GÃ©rer les changements de format d'API
- **Fallback** : ImplÃ©menter des mÃ©canismes de repli en cas d'Ã©chec

## âš¡ Performance et Optimisation
- ImplÃ©menter un debouncing pour les changements rapides de paramÃ¨tres
- Optimiser le rendu des marqueurs sur la carte
- GÃ©rer efficacement la mÃ©moire avec des cleanup appropriÃ©s
- Utiliser des lazy loading pour les composants non critiques
- Minimiser les re-renders avec React.memo et useMemo quand appropriÃ©

## âš™ï¸ Configuration et Constantes
- Centraliser les constantes dans des fichiers dÃ©diÃ©s (pollutants.ts, sources.ts, timeSteps.ts)
- Utiliser des noms scientifiques corrects pour les polluants (PMâ‚‚.â‚…, PMâ‚â‚€, Oâ‚ƒ, NOâ‚‚, SOâ‚‚)
- Maintenir la cohÃ©rence des codes et noms entre les constantes et l'interface
- Configurer les valeurs par dÃ©faut via le champ "activated"
- Organiser les sources en groupes logiques (principales, communautaires)
- Maintenir la cohÃ©rence des pas de temps (Scan, â‰¤2min, 15min, Heure, Jour)

### ğŸ”§ Configuration des APIs
- **Variables d'environnement** : Stocker les clÃ©s API et URLs dans .env
- **Configuration par source** : DÃ©finir les paramÃ¨tres spÃ©cifiques Ã  chaque API
- **Endpoints** : Centraliser les URLs d'endpoints dans des constantes
- **Headers** : Configurer les headers d'authentification et de contenu
- **Timeouts** : DÃ©finir des timeouts appropriÃ©s par source

## ğŸ› ï¸ DÃ©veloppement et Maintenance
- Utiliser TypeScript pour la sÃ©curitÃ© des types
- ImplÃ©menter des interfaces claires pour les props et les donnÃ©es
- Maintenir une structure de fichiers cohÃ©rente
- Utiliser des noms de variables et fonctions explicites
- Commenter le code complexe et les logiques mÃ©tier
- Tester les composants et hooks critiques
- Maintenir une sÃ©paration claire entre la logique mÃ©tier et l'interface

### ğŸ§ª Tests et Validation
- **Tests unitaires** : Tester chaque service de donnÃ©es individuellement
- **Tests d'intÃ©gration** : Valider l'intÃ©gration entre services et composants
- **Validation des donnÃ©es** : Tester la transformation et validation des donnÃ©es

## ğŸ”§ Conventions de Code
- Utiliser des guillemets simples pour les chaÃ®nes de caractÃ¨res
- PrÃ©fÃ©rer les fonctions flÃ©chÃ©es pour les composants React
- Utiliser des noms en camelCase pour les variables et fonctions
- Utiliser des noms en PascalCase pour les composants et interfaces
- Maintenir une indentation cohÃ©rente (2 espaces)
- Utiliser des commentaires en franÃ§ais pour la documentation

## ğŸ“± Responsive Design
- Concevoir l'interface pour Ãªtre responsive dÃ¨s le dÃ©part
- Utiliser les classes Tailwind responsive (sm:, md:, lg:, xl:)
- Adapter la taille des menus et contrÃ´les selon la taille d'Ã©cran
- Optimiser l'affichage de la carte sur mobile
- Maintenir la lisibilitÃ© sur tous les appareils

## ğŸ” SÃ©curitÃ© et Bonnes Pratiques
- **Variables d'environnement** : Ne jamais commiter les clÃ©s API
- **Validation des entrÃ©es** : Valider tous les paramÃ¨tres d'entrÃ©e
- **Sanitisation** : Nettoyer les donnÃ©es reÃ§ues des APIs
- **Rate limiting** : Respecter les limites des APIs tierces 
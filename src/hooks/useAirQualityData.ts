import { useState, useEffect, useCallback } from "react";
import { MeasurementDevice } from "../types";
import { DataServiceFactory } from "../services/DataServiceFactory";

interface UseAirQualityDataProps {
  selectedPollutant: string;
  selectedSources: string[];
  selectedTimeStep: string;
  signalAirPeriod?: { startDate: string; endDate: string };
}

export const useAirQualityData = ({
  selectedPollutant,
  selectedSources,
  selectedTimeStep,
  signalAirPeriod,
}: UseAirQualityDataProps) => {
  const [devices, setDevices] = useState<MeasurementDevice[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [loadingSources, setLoadingSources] = useState<string[]>([]);

  const fetchData = useCallback(async () => {
    if (selectedSources.length === 0) {
      setDevices([]);
      return;
    }

    console.log(
      `ðŸ”„ Appel API - Polluant: ${selectedPollutant}, Sources: ${selectedSources.join(
        ", "
      )}, Pas de temps: ${selectedTimeStep}${
        signalAirPeriod
          ? `, PÃ©riode SignalAir: ${signalAirPeriod.startDate} - ${signalAirPeriod.endDate}`
          : ""
      }`
    );

    // Nettoyer complÃ¨tement les donnÃ©es avant le nouvel appel
    setDevices([]);
    setLoading(true);
    setError(null);
    setLoadingSources(selectedSources);

    try {
      const services = DataServiceFactory.getServices(selectedSources);
      const allDevices: MeasurementDevice[] = [];

      // RÃ©cupÃ©rer les donnÃ©es de toutes les sources sÃ©lectionnÃ©es
      const promises = services.map(async (service, index) => {
        try {
          const data = await service.fetchData({
            pollutant: selectedPollutant,
            timeStep: selectedTimeStep,
            sources: selectedSources,
            signalAirPeriod,
          });

          // Retirer cette source de la liste des sources en cours
          setLoadingSources((prev) =>
            prev.filter((source) => source !== selectedSources[index])
          );

          return data;
        } catch (err) {
          console.error(
            `Erreur lors de la rÃ©cupÃ©ration des donnÃ©es pour ${service}:`,
            err
          );

          // Retirer cette source de la liste des sources en cours mÃªme en cas d'erreur
          setLoadingSources((prev) =>
            prev.filter((source) => source !== selectedSources[index])
          );

          return [];
        }
      });

      const results = await Promise.all(promises);
      results.forEach((devices) => allDevices.push(...devices));

      console.log(`âœ… DonnÃ©es rÃ©cupÃ©rÃ©es: ${allDevices.length} appareils`);
      setDevices(allDevices);
    } catch (err) {
      setError(
        err instanceof Error
          ? err.message
          : "Erreur lors de la rÃ©cupÃ©ration des donnÃ©es"
      );
      setDevices([]);
    } finally {
      setLoading(false);
      setLoadingSources([]);
    }
  }, [selectedPollutant, selectedSources, selectedTimeStep, signalAirPeriod]);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { devices, loading, error, loadingSources };
};
